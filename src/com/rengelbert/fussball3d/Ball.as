package com.rengelbert.fussball3d{	import flash.display.Sprite;		import away3d.entities.Mesh;	import away3d.materials.ColorMaterial;	import away3d.primitives.SphereGeometry;	import away3d.materials.TextureMaterial;	import away3d.utils.Cast;
		public class Ball extends GameSprite	{				[Embed(source="/../assets/ball.png")]		public static const BALL_TEXTURE:Class;				public var radius:int = 18;				public var squaredRadius:int;				private var _ricochet:Number = -0.8;		private var _bounce:Number = 0.2;		private var _friction:Number = 0.99;		private var _gravity:Number = 2.4;		private var _incline:Number = 0;				private var _bounceY:Number;		private var _bounceVy:Number;		private static const _MAX_VELOCITY:int = 12;				public function Ball(game:Fussball3d) {						super(game);						skin = new Sprite(); //for testing purposes if you want to see ball in 2D			//skin.graphics.beginFill(0x00FF00);			//skin.graphics.drawCircle(0,0,radius);			//game.container2d.addChild(skin);						var sphereG:SphereGeometry = new SphereGeometry (radius);			var material:TextureMaterial = new TextureMaterial (Cast.bitmapTexture(BALL_TEXTURE));			var sphere:Mesh = new Mesh (sphereG, material);			skin3d.addChild(sphere);			skin3d.y = radius;						//set initial position and direction for 2D ball			nextX = x = skin.x = radius;			nextY = y = skin.y = 200;			_bounceVy = 0;			_bounceY = 0;						vx = 4;			vy = 4;						squaredRadius = radius * radius;		}				public function bounce (force:Number):void {			_bounceVy += force * 0.008;		}				override public function place ():void {			super.place();						//place 3D sprite based on 2D coordinates			skin3d.x = x - game.screenWidth * 0.5;			skin3d.y = _bounceY;			skin3d.z = game.screenHeight * 0.5 - y;								}				override public function update (dt:Number):void {						//crappy rotation logic, the right way is through quaternions formula...			skin3d.rotationX -= vx;			skin3d.rotationZ -= vy;						//I have the option of adding slight gravity to the ball based on which			//half of the table the ball is currently (but right now incline = 0)			if (y > game.screenHeight * 0.5) {				vy += _incline;			} else {				vy -= _incline;			}						vx *= _friction;			vy *= _friction;						if (vx > _MAX_VELOCITY) vx = _MAX_VELOCITY;			if (vx < -_MAX_VELOCITY) vx = -_MAX_VELOCITY;			if (vy > _MAX_VELOCITY) vy = _MAX_VELOCITY;			if (vy < -_MAX_VELOCITY) vy = -_MAX_VELOCITY;						nextX += vx;			nextY += vy;						//check collision with sides			if (nextX > game.screenWidth - radius) {				nextX = game.screenWidth - radius;				vx *= _ricochet;				bounce(mag2d);			}						if (nextX < radius) {				nextX = radius;				vx *= _ricochet;				bounce(mag2d);			}						if (nextY < radius) {								nextY = radius;				vy *= _ricochet;				bounce(mag2d);			}						if (nextY > game.screenHeight - radius) {								nextY = game.screenHeight - radius;				vy *= _ricochet;				bounce(mag2d);			}						//this value will only be used to alter 3D Y of 3D sprite			_bounceVy -= _gravity;			_bounceY += _bounceVy;						if (_bounceY < radius) {				_bounceY = radius;				_bounceVy *= -0.5;			}					}	}}
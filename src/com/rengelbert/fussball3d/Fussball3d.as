package com.rengelbert.fussball3d{	import away3d.containers.ObjectContainer3D;	import away3d.containers.Scene3D;	import away3d.containers.View3D;	import away3d.entities.Mesh;	import away3d.materials.ColorMaterial;	import away3d.materials.TextureMaterial;	import away3d.primitives.CubeGeometry;	import away3d.primitives.CylinderGeometry;	import away3d.primitives.PlaneGeometry;	import away3d.utils.Cast;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.utils.getTimer;
			public class Fussball3d 	{				[Embed(source="/../assets/field.png")]		public static const FIELD_TEXTURE:Class;				[Embed(source="/../assets/wood.jpg")]		public static const WOOD_TEXTURE:Class;				//for testing purposes I'll keep a 2D 		//version of the game running along side the 3D		public var container2d:Sprite;		public var container3d:ObjectContainer3D;				public var screenWidth:int;		public var screenHeight:int;				private var _bars:Array = [];		private var _selectedBar:PlayerBar;		private var _ball:Ball;				private var _run:Boolean = false;		private var _stage:Sprite;				private var _view:View3D;				public function Fussball3d(stage:Sprite) {						_stage = stage;			screenWidth = _stage.stage.stageWidth;			screenHeight = _stage.stage.stageHeight;						//2D Stuff			_bars = [];						container2d = new Sprite();			_stage.addChild(container2d);									_stage.stage.addEventListener(MouseEvent.MOUSE_DOWN, on_MouseDown);			_stage.stage.addEventListener(MouseEvent.MOUSE_UP, on_MouseUp);			_stage.stage.addEventListener(MouseEvent.MOUSE_MOVE, on_MouseMove);						//this is the distance between goal keeper and top/bottom wall 			var margin:Number = screenHeight * 0.08;			//this is the distance between bars			var bar_gap:Number = (screenHeight - 2 * margin)/7;						_bars.push(new PlayerBar(this, Player.TEAM_1, 1, margin));			_bars.push(new PlayerBar(this, Player.TEAM_1, 2, margin + bar_gap));			_bars.push(new PlayerBar(this, Player.TEAM_2, 3, margin + bar_gap * 2));			_bars.push(new PlayerBar(this, Player.TEAM_1, 4, margin + bar_gap * 3));			_bars.push(new PlayerBar(this, Player.TEAM_2, 4, margin + bar_gap * 4));			_bars.push(new PlayerBar(this, Player.TEAM_1, 3, margin + bar_gap * 5));			_bars.push(new PlayerBar(this, Player.TEAM_2, 2, margin + bar_gap * 6));			_bars.push(new PlayerBar(this, Player.TEAM_2, 1, screenHeight - margin));									//add ball			_ball = new Ball(this);						//add goals (I add 2D representations of where the goals would be)			stage.graphics.beginFill (0x444444);			stage.graphics.drawRect (screenWidth * 0.5 - screenWidth * 0.2,									 0, screenWidth * 0.4, 10);			stage.graphics.drawRect (screenWidth * 0.5 - screenWidth * 0.2,									 screenHeight - 10, screenWidth * 0.4, 10);												//3D Stuff			_view = new View3D();			_stage.addChild(_view);						//init 3D scene			var scene:Scene3D = new Scene3D();			_view.scene = scene;						//setup the camera			_view.camera.z = -540;			_view.camera.lookAt(new Vector3D());						//create game container						container3d = new ObjectContainer3D();			scene.addChild(container3d);						//container3d.y = 50;			container3d.rotationX = -90;						//create geometry for for the bars (OBS: should be planes instead of cylinders)			var tube:CylinderGeometry = new CylinderGeometry(6, 6, screenWidth);			var bar:Mesh;			var len:int = _bars.length;			for (var i:int = 0; i < len; i++) {				container3d.addChild(_bars[i].skin3d);				//I apply color material to the bars with 80% opacity				bar = new Mesh (tube, new ColorMaterial(_bars[i].barColor(), 0.8));				//raise up the bar (this combined with 3d player Y position will shift center of				//gravity of player to a point closer to its head				bar.y = Player.PLAYER_LENGTH;				bar.z = screenHeight * 0.5 - _bars[i].y;				bar.rotationZ = 90;				container3d.addChild(bar);			}			container3d.addChild(_ball.skin3d);									//add ground			//create grass field			var planeMesh:Mesh;			var plane:PlaneGeometry = new PlaneGeometry (screenWidth + 10, screenHeight + 10);			var material:TextureMaterial = new TextureMaterial (Cast.bitmapTexture(FIELD_TEXTURE));			planeMesh = new Mesh(plane, material);			planeMesh.y = -1;			container3d.addChild(planeMesh);						//add wood frame around field			var frameSize:int = 80;			var woodMaterial:TextureMaterial = new TextureMaterial (Cast.bitmapTexture(WOOD_TEXTURE));						var planeGeometry:PlaneGeometry = new PlaneGeometry (frameSize, screenHeight);						var sideLeft:Mesh = new Mesh (planeGeometry, woodMaterial);			sideLeft.rotationZ = -90;			sideLeft.x =  - screenWidth * 0.5;			sideLeft.y = frameSize*0.5;			container3d.addChild(sideLeft);						var sideRight:Mesh = new Mesh (planeGeometry, woodMaterial);			sideRight.rotationZ = 90;			sideRight.x = screenWidth - screenWidth * 0.5;			sideRight.y = frameSize*0.5;			container3d.addChild(sideRight);									planeGeometry = new PlaneGeometry (frameSize, screenWidth);						var sideTop:Mesh = new Mesh (planeGeometry, woodMaterial);			sideTop.rotationZ = 90;			sideTop.rotationX = -90;						sideTop.z = screenHeight * 0.5;			sideTop.y = frameSize*0.5;			container3d.addChild(sideTop);						var sideBottom:Mesh = new Mesh (planeGeometry, woodMaterial);			sideBottom.rotationZ = -90;			sideBottom.rotationX = 90;						sideBottom.z = screenHeight * 0.5 - screenHeight;			sideBottom.y = frameSize*0.5;			container3d.addChild(sideBottom);						/*			IF you want to add Cubes for the frame instead of Planes 			var cubeGeometry:CubeGeometry = new CubeGeometry (frameSize, screenHeight, frameSize);			var cubeMeshLeft:Mesh = new Mesh (cubeGeometry, woodMaterial);			cubeMeshLeft.rotationX = 90;			cubeMeshLeft.x = -frameSize*0.5  - screenWidth * 0.5;			cubeMeshLeft.y = frameSize*0.5;			container3d.addChild(cubeMeshLeft);						var cubeMeshRight:Mesh = new Mesh (cubeGeometry, woodMaterial);			cubeMeshRight.rotationX = 90;			cubeMeshRight.x = screenWidth + frameSize*0.5  - screenWidth * 0.5;			cubeMeshRight.y = frameSize*0.5;			container3d.addChild(cubeMeshRight);						var cubeMeshTop:Mesh = new Mesh (cubeGeometry, woodMaterial);			cubeMeshTop.rotationX = 90;			cubeMeshTop.rotationY = 90;			cubeMeshTop.z = screenHeight * 0.5 - screenHeight - frameSize * 0.5;			cubeMeshTop.y = frameSize*0.5;			container3d.addChild(cubeMeshTop);						var cubeMeshBottom:Mesh = new Mesh (cubeGeometry, woodMaterial);			cubeMeshBottom.rotationX = 90;			cubeMeshBottom.rotationY = 90;			cubeMeshBottom.z = screenHeight * 0.5 + frameSize * 0.5;			cubeMeshBottom.y = frameSize*0.5;			container3d.addChild(cubeMeshBottom);			*/						_stage.addEventListener(Event.ENTER_FRAME, on_EnterFrame);						_view.width = screenWidth;			_view.height = screenHeight;					}				private var _timeThen:Number = 0;		private var _timeNow:Number = 0;				private function on_EnterFrame (event:Event):void {						_timeNow = getTimer();						update((_timeNow - _timeThen)*0.6);						_view.render();						_timeThen = _timeNow;					}				private function update (dt:Number):void {						_ball.update(dt);						var len:int = _bars.length;			for (var i:int = 0; i < len; i++ ) {								_bars[i].update(dt);				_bars[i].collideWithBall(_ball);				_bars[i].place();			}						_ball.place();				}				//for touch events I keep track of selected bar since I can only have one		//this logic disappears in the multi-touch supported version		private function on_MouseDown (event:MouseEvent):void {			//track player bars			var len:int = _bars.length;			for (var i:int = 0; i < len; i++ ) {				if (Math.abs(_bars[i].y - _stage.mouseY) < 40) {					_bars[i].selected = true;					_selectedBar = _bars[i];					_selectedBar.processMouseDown(new Point(_stage.mouseX, _stage.mouseY));					break;				}			}		}				private function on_MouseUp (event:MouseEvent):void {			if (_selectedBar) {				_selectedBar.processMouseUp(new Point(_stage.mouseX, _stage.mouseY));			}						var len:int = _bars.length;			for (var i:int = 0; i < len; i++ ) {				_bars[i].selected = false;			}			_selectedBar = null;		}				private function on_MouseMove (event:MouseEvent):void {			if (_selectedBar) {				_selectedBar.processMouseMove(new Point(_stage.mouseX, _stage.mouseY));			}		}			}}
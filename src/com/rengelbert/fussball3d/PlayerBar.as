package com.rengelbert.fussball3d{	import away3d.entities.Mesh;	import away3d.materials.ColorMaterial;	import away3d.primitives.CylinderGeometry;		import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Point;
		public class PlayerBar extends GameSprite	{		public static const RAD_TO_DEG:Number = 180 / Math.PI;		public static const TEAM_1_COLOR:uint = 0x66ccff;		public static const TEAM_2_COLOR:uint = 0xffff66;				public var selected:Boolean = false;		public var width:Number;		//the individual players in the bar		private var _players:Array;		private var _team:int;				private var _friction:Number = 0.85;				private var _currentTouch:Point;		private var _playerVector:Point;		private var _gap:Number;			private var _foot:Point;		private var _pivot:Point;				private var _canCollide:Boolean;				public function PlayerBar (game:Fussball3d, team:int, numPlayers:int, y:Number) {						super(game);			_team = team;			_gap = game.screenWidth / (numPlayers + 1);			this.y = y;						//add players			skin = new Sprite();			var player:Player;			_players = [];						for (var i:int = 0; i < numPlayers; i++) {								player = new Player(game, team, new Point((i + 1) * _gap, this.y));				_players.push(player);				//game.container2d.addChild(player.skin); //*** FOR TEST PURPOSES				skin3d.addChild(player.skin3d);			}						//calculate full width of occupied section of the bar 			//I'll use this to detect collision with sides			width = (numPlayers - 1) * _gap + Player.PLAYER_WIDTH;						nextX = _players[0].x;			//this variable changes based on rotation of player			//if foot is too far from the table, player cannot collide with ball			_canCollide = true;						//these points are rotated to emulate player's rotation			//_foot rotates around _pivot			_pivot = new Point(0, 0);			_foot = new Point (0, Player.PLAYER_LENGTH);						vx = vy = 0;			_playerVector = new Point (0,0);			skin3d.z = game.screenHeight * 0.5 - y;					skin3d.y = Player.PLAYER_LENGTH;		}				public function barColor ():uint {			return _team == 1 ? PlayerBar.TEAM_1_COLOR : PlayerBar.TEAM_2_COLOR;		}				public function collideWithBall (ball:Ball):void {						if (_canCollide) {				//check distance between ball and bar first				if (Math.abs(ball.y - y) < Player.PLAYER_RADIUS * 4 || Math.abs(ball.nextY - y) < Player.PLAYER_RADIUS * 4) {										var len:int = _players.length;					var squared_radii:Number = Math.pow(ball.radius + Player.PLAYER_RADIUS, 2); 					var collision:Boolean = false;					var diffx:Number;					var diffy:Number;					var d1:Number;					var d2:Number;					var angle:Number;					var force:Number;					var t:Number;					var player:Player;										for (var i:int = 0; i < len; i++) {												collision = false;												player = _players[i];												diffx = ball.nextX - player.nextX;						diffy = ball.nextY - player.nextY;												d1 = Math.pow(diffx, 2) + Math.pow(diffy, 2);						d2 = Math.pow(ball.x - player.nextX, 2) + Math.pow(ball.y - player.nextY, 2);												//check squared distances with squared radii						if (d1 <= squared_radii || d2 <= squared_radii) {							collision = true;													} else {							//if no collision check for time on Player Position Now, and Ball Position Now and Next							d1 = Math.pow(ball.x - player.x, 2) + Math.pow(ball.y - player.y, 2);							d2 = Math.pow(ball.nextX - player.x, 2) + Math.pow(ball.nextY - player.y, 2);														t = (squared_radii - d1) / (d2-d1);														if (t > 0 && t < 1) { 								collision = true							} else {								//if no collision check for time on Player Position Next, and Ball Position Now and Next								d1 =  Math.pow(ball.x - player.nextX, 2) + Math.pow(ball.y - player.nextY, 2);								d2 =  Math.pow(ball.nextX - player.nextX, 2) + Math.pow(ball.nextY - player.nextY, 2);								t = (squared_radii - d1) / (d2-d1);																if (t > 0 && t < 1) {																		collision = true;								}															}													}												//if collision was detected						if (collision ) {														//create force vector. Magnitude of player vector and half of ball's vector magnitude 							//OBS: all magnitudes are squared, so they are not proper vector lengths							var playerVectorMag:Number = _playerVector.x * _playerVector.x + _playerVector.y * _playerVector.y;							force = Math.sqrt(ball.mag2d * 0.5 + playerVectorMag);														diffx = ball.x - player.x;							diffy = ball.y - player.y;							angle = Math.atan2(diffy, diffx);														ball.vx =  force * Math.cos(angle);							ball.vy =  force * Math.sin(angle);														//position ball							ball.x = player.nextX + (Player.PLAYER_RADIUS + ball.radius) * Math.cos(angle);							ball.y = player.nextY + (Player.PLAYER_RADIUS + ball.radius) * Math.sin(angle);							ball.place();														ball.bounce(player.mag2d);						}																	}									}			}					}				override public function update (dt:Number):void {						//vy here means rotation velocity			vy *= _friction;						//stop rotating if velocity too low			if (Math.abs(vy) < 0.01) vy = 0;						//start calculating differences of foot position			//so we can create the foot movement vector			var prevX:Number = _foot.x;			var prevY:Number = _foot.y;						if (vy != 0) {				//rotate foot point around pivot point				var cos:Number = Math.cos(-vy);				var sin:Number = Math.sin(-vy);										var x1:Number = _foot.x - _pivot.x;				var y1:Number = _foot.y - _pivot.y;								var x2:Number = cos * x1 - sin * y1;				var y2:Number = cos * y1 + sin * x1;								_foot.x = _pivot.x + x2;				_foot.y = _pivot.y + y2;							}			//grab vector of bar's sideways movement			var sidewaysVectorX:Number = Math.abs(skin3d.x - (nextX + width * 0.5 - Player.PLAYER_WIDTH * 0.5 - game.screenWidth * 0.5));						//create player vector X with foot vector X + half of sideways Vector (0.5 is just to reduce strength)			_playerVector.x = _foot.x - prevX + sidewaysVectorX * 0.5;			//player vector Y is just the foot Y displacement in rotation			_playerVector.y = _foot.y - prevY;						//update nextX of each player			var len:int = _players.length;			for (var i:int = 0; i < len; i++) {				_players[i].nextX = nextX + i * _gap;				_players[i].nextY = y + (_foot.x - _pivot.x);			}						//determine if foot is close enough to ground for collision			_canCollide = (_foot.y - _pivot.y > 0 && 						   _foot.y - _pivot.y > Player.PLAYER_LENGTH * 0.3);			//I check the distance between foot and pivot points. 			//It must be positive: meaning the foot is coming down and not raised above player			//it must be at a certain distance from pivot otherwise it is still too far from ground			//pick values that look good. if > 0.3 collision is harder. if < 0.3 collision is easier		}				override public function place ():void {						var len:int = _players.length;			for (var i:int = 0; i < len; i++) {				_players[i].place();			}					//position bar			skin3d.x = nextX + width * 0.5 - Player.PLAYER_WIDTH * 0.5 - game.screenWidth * 0.5;			skin3d.rotationX += vy * RAD_TO_DEG;		}				public function processMouseDown (touch:Point):void {			_currentTouch = touch;		}				public function processMouseUp (touch:Point):void {						selected = false;					}				public function processMouseMove (touch:Point):void {						if (!selected) return;						//process swipe			var diffy:Number = _currentTouch.y - touch.y;						//process move			var diffx:Number = touch.x - _currentTouch.x;									if (Math.abs(diffy) > Math.abs(diffx) * 4) {				//reduce swipe factor otherwise bars rotate with no "friction"				diffy *= 0.06;				vy = diffy;			} else {				//add friction to sideways movement				diffx *= 0.8;				nextX += diffx;							//check collision of bar with sides				if (nextX < Player.PLAYER_WIDTH * 0.5) {					nextX = Player.PLAYER_WIDTH * 0.5;				}								if (nextX > game.screenWidth - width + Player.PLAYER_WIDTH * 0.5) {					nextX = game.screenWidth - width + Player.PLAYER_WIDTH * 0.5;				}			}						_currentTouch = touch;					}	}}